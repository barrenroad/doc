# 微前端专栏

## 什么是微前端
- 适用于大型中后台管理系统：因为随着公司的发展，内部的各种中后台系统会越来越多。
- 如果每个系统都用SPA的形式来开发，那么每个系统都需要单独的域名来承载，多了就记不住，而且个应用间如果有相互依赖跳转的话，将频繁的浏览器重载刷新跳转，体验不好
- 如果维护在同一个代码仓库中，那么仓库会越来越臃肿，维护困难、打包困难、测试困难（改了其中某个小的功能点，需要全量回归测试）、无法独立发布。
- 基于以上的痛点问题，微前端解决方案应运而生。借鉴了微服务的思想，将一个大的应用按功能模块拆分成若干个微小的子应用，子应用单独开发、打包、测试、发布，各子应用间互不影响。最后再将子应用统一组合到一个主应用中。达到统一入口，且各应用独立维护的目的，并且应用切换时可以达到单页应用中的局部刷新体验。
应用场景
工作台的场景：基于产品体验维度
- 多个管理后台聚合成统一的工作台
大型单体应用：侧重于从技术角度优化
- 单体应用过于巨大，不利于开发维护
微前端方案的好处
- 巨型应用拆成小应用后可以交由不同的团队维护不同的功能模块，子应用独立开发、维护、构建、测试、部署
- 统一入口，提升统一体验，一体化配置
- 还可以整合不同技术栈的项目，如Vue、React、Angela等或者是历史老项目
核心思想
- 微前端的核心在于拆，拆完之后再合。
- 将一个大应用划分成一个个子应用，将子应用打包成一个一个的lib资源，在路由切换的时候去匹配各个子应用的名字，匹配上就加载对应的子应用资源
如何落地微前端
各个公司基于不同的内部环境有不同的微前端实现方案，这里主要介绍两种：SingleSpa、qiankun。
- Single-Spa微前端解决方案诞生于2018年，实现了路由劫持和应用加载（本身没有实现样式隔离和JS沙箱）
- qiankun微前端解决方案诞生于2019年，2020年发布了更加完善的2.x版本，它是基于Single-Spa，在Single-Spa的基础上，实现了一套开箱即用的API，做到了：技术栈无关，且接入简单
- 协议接入：子应用必须导出 bootstrap、mount、unmount方法，放主应用去调用

## 1. SingleSpa实战
- [SingleSpa实战](Single-Spa实战/readme.md)
## 2. qiankun实战
- [qiankun实战](qiankun实战/readme.md)
## 3. CSS隔离方案
- [样式隔离](样式隔离/readme.md)

## 4. JS沙箱机制-应用隔离
- [沙箱实现](沙箱实现/readme.md)

## 5. 实际运用中遇到的问题
前端现存问题
- 需要解决子应用简单配置即可加载，本地开发测试、还有预加载资源
- 需要解决APP级别隔离与无缝切换
- 子应用原有路由跳转不受干扰
后端现存问题
- 如何解决主子应用接口跨域的问题
- 如何解决各应用间登录互通的问题
- 如何解决子应用post请求拦截问题
- 如何支持子应用请求接口Proxy 转发
## 6. 问题
1. 与iframe的区别？iframe的不足？--> 不熟
- 当子应用用iframe加载，用户切换路由时刷新页面的话，状态会丢失
- 父子应用通信问题，使用成本过高
2. 应用间的通信问题
- 如果采用URL参数，那么消息传递能力弱，只能以字符串的形式显示的放在URL上，也不优雅
- 基于 CustomEvent 实现通信，浏览器自定义事件
- 基于 Props 主子应用通信
- 使用全局变量、redux 通信
3. 公共依赖
- webpack 5.x Federated Modules（联合模块）
- cdn - externals
4. 不同应用依赖同一包的不同版本如何处理？
- 比如React，可以使用DLL
5. 前端进行微前端改造后，可能会涉及不同应用的域名合并，导致跨域
- 服务端也需要做出相应的调整
- 跨域线上一般配置Nginx代理解决 --> 待确定
6. 希望听听毛宝分享底层编译方面的开发
- 目前还是处于实现业务需求的层面，需要开阔一下视野
- 希望能有实际的案例分享，让我们切身的感受一下