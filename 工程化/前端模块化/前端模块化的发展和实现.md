### 前端模块化

#### 什么是模块？
* webpack中给出的定义：在模块化编程中，每个模块都拥有小于完整程序的体积，使得验证，调试及测试变得轻而易举。精心编写的 模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具备了条理清晰的设计和明确的目的。

具有以下特点：

1. 职责单一，相互独立，低耦合的，高度内聚且可以替换的离散功能块；
2. 逻辑抽象和高度封装的功能块。

#### 模块化/为什么需要模块化？
* 模块化就是一种`分治`的编程思想，通过一个复杂的系统分解为一个个独立的模块

* 由前端开发的特性决定——一个基本的前端应用包含html，css，js等不同类型的基础资源，面向的开发对象是浏览器，这些资源是通过增量加载的方式组织运行到浏览器中，怎么在开发环境组织碎片化的代码和资源，从而保证它们在浏览器中快速，优雅的加载和更新，因此需要一个模块化的系统用于控制。

#### 模块化的历史发展（实现方案）
* 模块化的发展从原始的全局变量模块定义，最终到业界成熟的模块化方案经历了漫长的过程，包含以下几个阶段：

1. 全局定义的函数，模块，通过script标签引入
```js
function fn1() {}
function fn2() {}
```
主要问题：需要手动管理对应的依赖顺序，同时容易造成命名冲突，引起全局变量的污染

2. 利用命名空间
```js
var module = {
  _count: 0,
  fn: function() {
      
  }
}
```
主要问题：项目复杂度提升后，需要维护更多的全局对象，同时模块内部的属性是可以被直接访问和更改的，无法保证模块的安全性。

3. 经典实现——闭包（现代模块化框架的核心加载机制）
```js
var MyModules = (
  function Manage () {
    var modules = {};
    function define(name, deps, impl) {
      // name-定义的模块名称，deps-当前模块需要依赖的模块，impl-模块加载成功执行的回调
      for (var i=0, l=deps.length; i<l; i++) {
        deps[i] = modules[deps[i]];
      }
      modules[name] = impl.apply( impl, deps );
    }
    function get(name) {
      return modules[name];
    }
    return {
      define: define,
      get: get
    }
  }
)()
```

#### 现代化主要的模块化方案
* 主要包括Common.js，AMD和CMD，以及ES6的module

1. CommonJS采用的是同步加载资源的方式，主要原因在于服务端的文件都储存在本地磁盘种，读取的速度非常快.
```js
module.exports = {}
```

2. AMD，对应的框架是requireJS，采用的是异步加载的模块化加载方案，对应的依赖是否加载完成并不影响后续代码的执行，因为所有的异步代码都放到加载完成的回调里面执行。原则：依赖前置，提前加载执行。
```js
require.config // 配置模块的基础引用路径
define // 定义基础模块
require // 加载定义好的基础模块
```

3. CMD，对应额框架是seaJS，原则是就近依赖，延迟执行，和AMD规范不同的是需要某个模块的时候再去声明并加载该模块内容。

4. UMD，即javascript的一个`通用模块定义的规范`，让模块在任何js环境中都可以运行。
* 主要原理就是通过判断当前环境支持什么规范，按照对应的规范加载模块。

5. ES6的module方案，输出的是一个引用，模块的原始值发生变化，import加载进来的值也会发生变化
```js
exports const a = 1
exports default { b }
import { a } from ''
import b from ''
```

* ES6的module对比CommonJS
1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用;
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
3. CommonJS加载的是一个对象（module.exports属性），对象只有在运行时才能生成。ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成.
4. ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值.
5. CommonJS：一旦输出一个值，模块内部的变化就影响不到这个值，ES6：输出的是一个只读引用，模块的原始值发生变化，import加载进来的值也会发生变化。

* 现代浏览器对于ES6的module的支持
```js
<script type="module"></script> // 用于加载原生的ES6模块
```